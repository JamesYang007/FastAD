#pragma once
#include <tuple>
#include "node.hpp"
#include "vec.hpp"

namespace ad {
namespace core {

// Exgen is a small wrapper of a lambda function that may return
// an expression given variables and other information.
// The purpose of this class is to encapsulate the temporary, optimizing placeholder
// that typically gets used when creating an expression:
// Ex. 
// (w[0] = ..., w[1] = ..., ...)
// Here the (likely) Vec w acts as a placeholder.
// Since it has no useful information for the user, it should be hidden from user.
// 
// It is assumed that user will provide a lambda function with the last parameter
// representing the optimizing placeholder (w in example).
template <class ValueType, class... Fs>
struct Exgen
{
    Exgen(const Fs&... fs)
        : tup_fs_(fs...)
    {}

    // Generates a tuple of expressions by collecting results of
    // delegating "generate" to the underlying univariate Exgen functions with args.
    // User may provide a template parameters that specify the placeholder size for every function.
    
    // This function will only be called if the number of opt_sizes
    // matches the number of functions, i.e. user must specify all placeholder sizes
    // for every function, even if they only wish to specify one.

    // Note that if user autodifferentiates with seed1, ..., seedn 
    // for the resulting expressions expr1, ..., exprn representing functions f1,...,fn,
    // then for each variable x, the adjoint contains directional derivative of
    // (f1,...,fn) in direction (seed1,...,seedn).
    template <size_t... opt_sizes, class... Args>
    auto generate(Args&&... args)
    {
        return generate_<opt_sizes...>(std::make_index_sequence<sizeof...(Fs)>(),
                std::forward<Args>(args)...);
    }

private:
    // Helper function to unpack tuple
    template <size_t... opt_sizes, class... Args, size_t... I
            , class = std::enable_if_t<(sizeof...(opt_sizes) == sizeof...(Fs))> >
    auto generate_(std::index_sequence<I...>, Args&&... args)
    {
        return std::make_tuple(std::get<0>(std::get<I>(tup_fs_).template 
                generate<opt_sizes>(std::forward<Args>(args)...))...);
    }

    template <class... Args, size_t... I>
    auto generate_(std::index_sequence<I...>, Args&&... args)
    {
        return std::make_tuple(std::get<0>(std::get<I>(tup_fs_).
                generate(std::forward<Args>(args)...))...);
    }

    std::tuple<Exgen<ValueType, Fs>...> tup_fs_;
};

template <class ValueType, class F>
struct Exgen<ValueType, F>
{
    using placeholder_t = Vec<ValueType>;
    Exgen(const F& f)
        : f_(f), placeholders_(), is_set_(false)
    {}

    // Copy constructor is defined to copy lambda function and is_set_ variable.
    // The placeholder vector is to be newly constructed with the same size, but
    // no contents are copied. The vector is not exposed outside of the class,
    // and the values change at every evaluation of expression after generation.
    // Adjoints are also reset before generation, hence, there is no point of copying any data.
    // Note that the LeafNodes in the vector contain pointers for value and adjoint destination.
    // They CANNOT be pointing to those in gen.placeholders_ members (leads to seg fault).
    Exgen(const Exgen& gen)
        : f_(gen.f_), placeholders_(gen.placeholders_.size()), is_set_(gen.is_set_)
    {}

    Exgen(Exgen&& gen)
        : f_(gen.f_)
        , placeholders_(gen.placeholders_.size())
        , is_set_(gen.is_set_)
    {}

    // Generates the expression by calling the underlying lambda function with args.
    // By default, find the resulting glue expression size and resize placeholders_ to it.
    // Idea is that since every piece glued must be an EqNode,
    // where the LHS must be a unique placeholder, it is general enough
    // to assume every placeholder runs contiguously in the vector of placeholders:
    // (w[0] = ..., w[1] = ..., w[2] = ..., ...)
    //
    // If user specifies a template parameter opt_size, then the underlying placeholder
    // vector will be reset to this size.
    //
    // At every call to generate, placeholders will reset their adjoints to 0.
    // It is expected that the user specified the last parameter of
    // lambda function as the "optimization" placeholders that are used
    // when glueing placeholder equations.
    // @return tuple of one expression generated by lambda function

    template <size_t opt_size, class... Args>
    auto generate(Args&&... args)
    {
        if (!is_set_) {
            placeholders_.resize(opt_size);
            is_set_ = true;
        }

        return generate_(std::forward<Args>(args)...);
    }

    template <class... Args>
    auto generate(Args&&... args)
    {
        if (!is_set_) {
            using expr_t = std::decay_t<
                decltype(f_(std::forward<Args>(args)..., placeholders_))>;
            constexpr size_t size = details::glue_size<expr_t>::value;
            placeholders_.resize(size);
            is_set_ = true;
        }
    
        return generate_(std::forward<Args>(args)...);
    }

private:
    template <class... Args>
    auto generate_(Args&&... args) 
    {
        placeholders_.reset_adjoint();  // reset adjoints to 0
        return std::make_tuple(f_(std::forward<Args>(args)..., placeholders_));
    }

    const F f_;
    placeholder_t placeholders_;
    bool is_set_;
};

namespace details {

template <class T>
struct is_exgen : std::false_type
{};

template <class ValueType, class... Ts>
struct is_exgen<ad::core::Exgen<ValueType, Ts...>> : std::true_type
{};

} // namespace details

template <class T>
inline constexpr bool is_exgen = details::is_exgen<T>::value;

} // namespace core

// ad::make_exgen<ValueType>(Fs&&...)
template <class ValueType, class... Fs>
inline auto make_exgen(Fs&&... fs)
{
    return core::Exgen<ValueType, Fs...>(std::forward<Fs>(fs)...);
}

} // namespace ad
